---
title: "A Quirk in InnoDB's READ UNCOMMITTED"
date: 2025-01-31
tags:
  - mysql
categories:
  - MySQL
---

A while back, I found a quirk in InnoDB's `READ UNCOMMITTED` transaction isolation level, and I don't think it's documented anywhere.

InnoDB uses Multi-Version Concurrency Control (MVCC) to provide consistent reads (where all rows belong to the same point in time, no matter
how long the scan takes) and prevent non-repeatable reads in `READ COMMITTED`, `REPEATABLE READ`, and `SERIALIZABLE`. `READ UNCOMMITTED`, in
contrast, does not use MVCC, so the rows it retrieves in a single statement can belong to different point in times. This isn't super clear
in the documentation, but a few authoritative sources are more explicit:

[//]: # (@formatter:off)
> Within a single statement, transactional inconsistencies may be seen from one record to the next, because no record is ever reverted to a
> previous version [by using MVCC] during a read (Jeremy Cole, "[The Basics of the InnoDB Undo Logging and History System](https://blog.
> jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/)").

> READ UNCOMMITTED isolation mode means InnoDB never needs to go and examine the older row versions â€“ the last row version is always the
> correct one (Peter Zaitsev, "[MySQL performance implications of InnoDB isolation modes](https://www.percona.com/blog/mysql-performance-implications-of-innodb-isolation-modes/)").

[//]: # (@formatter:on)

Let's try this out with a few examples. In the following snippets, I'm going to show two concurrent SQL sessions, one on the left, and one
on the right. Assume all transactions are set to `READ UNCOMMITTED`. First, let's reproduce a non-consistent read:

[//]: # (@formatter:off)
```sql
create table t (
  num int
)

insert into t values 
(1), (2), (3), (4), (5);

-- give ourselves time
-- by slowing down the scan
select num, sleep(1)
from t;

                                -- while the select is running
                                update t
                                set num = 12345;

-- returns
-- 1, 2, 3, 12345, 12345
```
[//]: # (@formatter:on)

We can see that the result of the right-side transaction shows up only partially in the left-side transaction, because some rows had already
been read when the `UPDATE` happened. So reads really are non-consistent. This effect also applies to `INSERT` and `DELETE`. Now let's try
it with a slightly different table:

[//]: # (@formatter:off)
```sql
create table t (
  num primary key;
);

select num, sleep(1)
from t;

                                -- while the select is running
                                update t
                                set num = 12345;

-- returns
-- 1, 2, 3, 4, 5
```
[//]: # (@formatter:on)

No non-consistent read here! And the only difference is that `num` is now the primary key, whereas previously the primary key
was [based on a hidden column generated by InnoDB](https://dev.mysql.com/doc/refman/8.4/en/innodb-index-types.html). The non-consistent read
is also prevented when the table has an [implicit primary key](https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html), for example
with this table:

[//]: # (@formatter:off)
```sql
create table t (
  num int unique not null
);
```
[//]: # (@formatter:on)

It seems that non-consistent reads only occur in tables that have an auto-generated primary key. I'm not quite sure why, and AFAIK this is
undocumented.

I'm heading to [ScALE 22x](https://www.socallinuxexpo.org/scale/22x) in March, where there's a MySQL track, so I'm sure I'll have an
opportunity to discuss this with some really smart people, and I'll post about it here if I learn more.
